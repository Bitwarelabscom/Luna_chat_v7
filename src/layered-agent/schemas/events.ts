/**
 * Event Schema - Event Sourcing Types
 *
 * Defines state events for the append-only event log
 * and the AgentView snapshot computed from events.
 */

import { z } from 'zod';

// Event types that can be recorded
export const StateEventTypeSchema = z.enum([
  'topic_shift',    // Conversation topic changed
  'mood_change',    // User mood detected/changed
  'task_update',    // Active task changed
  'user_goal',      // User expressed a goal
  'interaction',    // General interaction marker
]);
export type StateEventType = z.infer<typeof StateEventTypeSchema>;

// Individual state event
export const StateEventSchema = z.object({
  event_id: z.string().uuid().optional(), // Generated by DB
  session_id: z.string().uuid(),
  turn_id: z.string().uuid().optional(),  // Message that triggered event
  event_type: StateEventTypeSchema,
  event_value: z.string(),
  ts: z.date().optional(),                // Set by DB
  meta: z.record(z.unknown()).optional(), // Additional structured data
});
export type StateEvent = z.infer<typeof StateEventSchema>;

// Input for creating new events (without DB-generated fields)
export const StateEventInputSchema = StateEventSchema.omit({
  event_id: true,
  ts: true,
});
export type StateEventInput = z.infer<typeof StateEventInputSchema>;

// AgentView - computed snapshot from event log
export const AgentViewSchema = z.object({
  current_topic: z.string().nullable(),
  current_mood: z.string().nullable(),
  active_task: z.string().nullable(),
  active_plan: z.string().nullable(),
  interaction_count: z.number().int().nonnegative(),
});
export type AgentView = z.infer<typeof AgentViewSchema>;

// Database row type for state_events table
export interface StateEventRow {
  event_id: string;
  session_id: string;
  turn_id: string | null;
  event_type: StateEventType;
  event_value: string;
  ts: Date;
  meta: Record<string, unknown> | null;
}

/**
 * Reducer function to compute AgentView from events
 * This is the core of event sourcing - replaying events to get current state
 */
export function reduceEventsToView(events: StateEventRow[]): AgentView {
  const view: AgentView = {
    current_topic: null,
    current_mood: null,
    active_task: null,
    active_plan: null,
    interaction_count: 0,
  };

  // Sort events by timestamp (should already be sorted, but ensure)
  const sorted = [...events].sort((a, b) => a.ts.getTime() - b.ts.getTime());

  for (const event of sorted) {
    switch (event.event_type) {
      case 'topic_shift':
        view.current_topic = event.event_value;
        break;
      case 'mood_change':
        view.current_mood = event.event_value;
        break;
      case 'task_update':
        view.active_task = event.event_value;
        break;
      case 'user_goal':
        view.active_plan = event.event_value;
        break;
      case 'interaction':
        view.interaction_count++;
        break;
    }
  }

  return view;
}

/**
 * Derive events from user input using heuristics
 * Later this can be replaced with LLM-based event extraction
 */
export function deriveEventsFromInput(
  sessionId: string,
  turnId: string,
  userInput: string,
  currentView: AgentView
): StateEventInput[] {
  const events: StateEventInput[] = [];
  const lowerInput = userInput.toLowerCase();

  // Always record an interaction event
  events.push({
    session_id: sessionId,
    turn_id: turnId,
    event_type: 'interaction',
    event_value: 'user_message',
    meta: { length: userInput.length },
  });

  // Detect topic shifts (simple heuristic - questions about new subjects)
  const topicPatterns = [
    { pattern: /what (?:is|are) (\w+(?:\s+\w+)?)/i, extractor: (m: RegExpMatchArray) => m[1] },
    { pattern: /tell me about (\w+(?:\s+\w+)?)/i, extractor: (m: RegExpMatchArray) => m[1] },
    { pattern: /how (?:do|does|can) (?:i|we|you) (\w+)/i, extractor: (m: RegExpMatchArray) => m[1] },
    { pattern: /let's talk about (\w+(?:\s+\w+)?)/i, extractor: (m: RegExpMatchArray) => m[1] },
  ];

  for (const { pattern, extractor } of topicPatterns) {
    const match = userInput.match(pattern);
    if (match) {
      const topic = extractor(match);
      if (topic && topic !== currentView.current_topic) {
        events.push({
          session_id: sessionId,
          turn_id: turnId,
          event_type: 'topic_shift',
          event_value: topic.toLowerCase(),
        });
        break;
      }
    }
  }

  // Detect mood signals
  const moodIndicators: Array<{ keywords: string[]; mood: string }> = [
    { keywords: ['frustrated', 'annoying', 'angry', 'upset', 'hate'], mood: 'negative' },
    { keywords: ['happy', 'excited', 'great', 'wonderful', 'love'], mood: 'positive' },
    { keywords: ['confused', 'not sure', "don't understand", 'help'], mood: 'uncertain' },
    { keywords: ['tired', 'exhausted', 'sleepy', 'drained'], mood: 'low_energy' },
  ];

  for (const { keywords, mood } of moodIndicators) {
    if (keywords.some(k => lowerInput.includes(k))) {
      if (mood !== currentView.current_mood) {
        events.push({
          session_id: sessionId,
          turn_id: turnId,
          event_type: 'mood_change',
          event_value: mood,
        });
      }
      break;
    }
  }

  // Detect goal expressions
  const goalPatterns = [
    /i want to (\w+(?:\s+\w+)*)/i,
    /i need to (\w+(?:\s+\w+)*)/i,
    /i('m| am) planning to (\w+(?:\s+\w+)*)/i,
    /my goal is to (\w+(?:\s+\w+)*)/i,
    /i'd like to (\w+(?:\s+\w+)*)/i,
  ];

  for (const pattern of goalPatterns) {
    const match = userInput.match(pattern);
    if (match) {
      const goal = match[match.length - 1]; // Last capture group
      if (goal && goal.length > 3) {
        events.push({
          session_id: sessionId,
          turn_id: turnId,
          event_type: 'user_goal',
          event_value: goal.toLowerCase(),
        });
        break;
      }
    }
  }

  // Detect task mentions
  const taskPatterns = [
    /(?:can you|please|could you) (\w+(?:\s+\w+){0,5})/i,
    /i need (?:you to )?(\w+(?:\s+\w+){0,5})/i,
  ];

  for (const pattern of taskPatterns) {
    const match = userInput.match(pattern);
    if (match) {
      const task = match[1];
      if (task && task.length > 3 && task !== currentView.active_task) {
        events.push({
          session_id: sessionId,
          turn_id: turnId,
          event_type: 'task_update',
          event_value: task.toLowerCase(),
        });
        break;
      }
    }
  }

  return events;
}

/**
 * Format AgentView for prompt injection
 */
export function renderViewForPrompt(view: AgentView): string {
  const parts: string[] = ['[Agent State]'];

  if (view.current_topic) {
    parts.push(`Current Topic: ${view.current_topic}`);
  }
  if (view.current_mood) {
    parts.push(`User Mood: ${view.current_mood}`);
  }
  if (view.active_task) {
    parts.push(`Active Task: ${view.active_task}`);
  }
  if (view.active_plan) {
    parts.push(`User Goal: ${view.active_plan}`);
  }
  parts.push(`Interaction Count: ${view.interaction_count}`);

  return parts.join('\n');
}

export default {
  StateEventSchema,
  StateEventInputSchema,
  AgentViewSchema,
  reduceEventsToView,
  deriveEventsFromInput,
  renderViewForPrompt,
};
